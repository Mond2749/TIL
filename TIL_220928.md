# 판다스 설명(pandas)
- series, DataFrame등의 자료구조를 활용한 데이터분석 기능을 제공해주는 라이브러리
- 라이브러리 구성
    - 여러종류의 클래스와 다양한 함수로 구성
    - 시리즈와 데이터 프레임의 자료 구조 제공
    - 시리즈(1차원 배열) 데이터프레임(2차원 행열 구조)
판다스의 목적
- 서로 다른 유형의 데이터를 공통된 포맷으로 정리하는 것
- 행과 열로 이루어진 2차원 데이터프레임을 처리 할 수 있는 함수제공 목적
- 실무 사용 형태 : 데이터 프레임

Series 
- pandas의 기본 객체 중 하나
- numpy의 ndarray를 기반으로 인덱싱을 기능을 추가하여 1차원 배열을 나타냄
- index를 지정하지 않을 시, 기본적으로 ndarray와 같이 0-based 인덱스 생성, 지정할 경우 명시적으로 지정된 index를 사용

1. 자료구조 : 순차 1차원 배열, 인덱싱 : 데이터 , dict형식의 키 : 벨류 -> 시리즈
2. 시리지의 인덱싱 : 레이블추가, 데이터 관리,[리스트]
3. 시리즈 생성 : Series()를 통해서 데이터를 나열 지정-> 리스트-> 튜플-> 딕셔너리(xml,json)

```python
import pandas as pd
import numpy as np

# 1. Series 객체 생성 : p[ ] 나열된 데이터 생성
s= pd.Series([1,2,3,4,5],index=['AA','BB','CC','DD','EE'])
print(s,s.dtype,s.index,s.array,s.values,s.shape,s.ndim)
s.index.name='test'
s.name
```
```python
print(s.array.values)

ser = pd.Series(pd.Categorical(['a', 'b', 'a']))
ser

s.name='이름 컬럼'
s

#s에서 3과 5를 추출해보자.
s['CC'],s['EE']

#s에서 3과 5의 값을 3000과 5000으로 변경해보자.
s['CC']=3000
s['EE']=5000
s

# Series 객체 생성 : p[ ] 나열된 데이터 생성
#s= pd.Series([1,[2,3],4,5]
s= pd.Series([1,[2,3],4,5],index=['AA','BB','CC','DD'])
print(s,s.dtype,s.index,s.array,s.values,s.shape,s.ndim)
s.index.name='test'
s.name

#인덱스를 문자열로 지정한 후에 숫자 인덱스로 추출 확인
#s['AA']
s[0]=1000
s['AA']

#문제 인데스,로 나열해서 데이터를 추출해보자._슬라이싱으로 추출 가능하다.
s[['BB','CC']]
s['BB':'CC']

#객체.인덱스로 추출해보자.
s.BB=7777
s.BB

#exam) 문자 인덱스의 시리즈이다. 아래와 같은 결과를 출력할 수 있도록 코드를 작성해본다.
#도시 
#서울 9904312
#부산 3448737
#인천 289045
#대구 2466052
#Name: 인구, dtype : int64

res=pd.Series([9904312,3448737,289045,2466052],
             index=['서울','부산','인천','대구'],name='인구')
res.index.name='도시'
res

```

```python

res=pd.Series([9904312,3448737,289045,2466052],
             index=['서울','부산','인천','대구'],name='인구')
res.index.name='도시'
res

r=pd.Series([1,2,3]).array
print(type(r))


#백터화 연산 _range로 데이터 지정
data=range(1,10,2)
print(len(data))
pd.Series(data,index=range(1,len(data)+1))


#벡터화 연산
pd.Series([1,2,3])+4
r=pd.Series([1,2,3])
r+4,r-1,r*3,r/100000


#인구지표를 축소해보자.
res/100000


#비교연산을 이용해서 데이터를 추출 해보자.
s1= pd.Series(range(1,20))
s1[s1%2 ==0] # 논리연산 수행 가능


#인덱스가 연산을 수행 15보다 큰 데이터 
s1[s1.index>15]


s1.items,s1.iteritems,s1.keys,s1.item


#시리즈 함수를 이용해서 목록을 출력해보자.
s1.items()
for index, value in s1.items():
    print(f"Index : {index}, Value : {value}")

s1.keys()
s1.item()


#시리즈 간의 연산
a1=pd.Series([1,2,3,4],index=['a','b','c','d'])
b1=pd.Series([1,2,3,4],index=['a','b','c','d'])
a1+b1
#a1*b1

# 시리즈 간의 연산_ 인덱스이름이 같아야 한다.
a1=pd.Series([1,2,3,4],index=['a','b','c','d'])
b1=pd.Series([1,2,3,4],index=['aa','bb','c','d'])
a1+b1

d = {'a': 1, 'b': 2, 'c': 3}
#ser = pd.Series(data=d, index=['x', 'y', 'z'])
ser=pd.Series(data=d)
ser.index


# res소스코드로 확인 해보자. _dict로 만들어 보자.
city = {'서울': 9904312
, '부산': 3448737
, '인천': 1344515
,'대구':2466052
}
r=pd.Series(data=city,index=city.keys())
r.서울=90000000

# r의 요소중 대전을 삭제해보자.
del r['대구']

```

Series size, shape, unique, count, value_counts 함수

size : 개수 반환
shape : 튜플형태로 shape반환
unique: 유일한 값만 ndarray로 반환
count : NaN을 제외한 개수를 반환
mean: NaN을 제외한 평균
value_counts: NaN을 제외하고 각 값들의 빈도를 반환
판다스 패키지의 date_range 함수 (날짜생성)

pd.date_range(start=None, end=None, periods=None, freq='D')
start : 시작날짜/ end= 끝날짜 / periods = 날짜 생성기간/ fref = 날짜 생성 주기
start는 필수 옵션/end나 periods는 둘 중 하나가 있어야 함/ freq는 기본 Day로 설정

![](http://localhost:8888/view/work01/date_attribute.PNG)

```python
a = np.array([2,2,2,2,np.NaN]) 

print(a,a.mean())  # 넘파이의 array에 대해 mean(평균값) 을 적용하면 평균 계산에 NaN이 적용되어 nan이 반환

b = pd.Series(a) # 배열을 시리즈로 변경
print(b.mean())  # 판다스의 시리즈는 NaN값을 빼고 계산해준다.
# 각 원소들에 대해 동일 값의 원소끼리 그룹핑하여 개수를 세서 반환하는 함수
print(b.sum())
b

# 각 원소들에 대해 동일 값의 원소끼리 그룹핑하여 개수를 세서 반환하는 함수 
pd.Series([1,1,3,4,4,2,2,2,2,2,2]).value_counts()


pd.date_range(start='2018-10-01',end='2018-10-20')
#DatetimeIndex를 반환
#인덱스니까 시리즈에 붙일 수 있음
#dtype='datetime64[ns]'


#요일로 생성
pd.date_range(start='2018-10-01',end='2018-10-20',freq='w')

pd.date_range(start='2018-10-01',end='2018-10-20',freq='3d')

#스타트를 기준으로 2bm 2개월 간격으로 월말주기 12개 생성하겠다.
pd.date_range(start='2018-10-01',periods=12,freq='2BM')


pd.date_range(start='2018-10-01',periods=12,freq='Q') #분기별로


#q3) 넘파이 np.random.randint()를 이용해서 난수 10개 생성해 보자.
r1=np.random.randint(5,size=10)

#q4) 넘파이 np.random.seed()를 찾아서 시간을 지정한 후 난수를 10개 생성해보자.
import time
print(time.time())
np.random.seed(int(time.time()))
np.random.randint(5,size=10)


import time
print(time.time())
np.random.seed(int(time.time()))
np.random.randint(5,size=10)
```

