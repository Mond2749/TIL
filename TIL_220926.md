# SQL 퀴즈
### Q20)매니저가 없는 사원의 매니저ID를 1000번으로 표시
```SQL
select EMPLOYEE_ID,LAST_NAME,NVL(MANAGER_ID,1000)
FROM EMPLOYEES;
```
### Q19)사원테이블에서 사원번호, 이름, 급여, 커미션, 연봉을 출력하시오.
- 조건1 연봉은 $표시와 세자리마다 콤마를 사용하시오.
- 조건2 연봉 = 급여 *12 + (급여*12*커미션)
- 조건3) 커미션을 받지 않는 사원도 포함해서 출력하시오.
```SQL
SELECT EMPLOYEE_ID,LAST_NAME,SALARY,NVL(COMMISSION_PCT,0),
TO_CHAR(SALARY*12+(SALARY*12*NVL(COMMISSION_PCT,0)),'$999,999,999') 연봉
FROM EMPLOYEES;
```
### Q18) 급여가 10000미만이면 초급, 20000미만이면 중급 그 외면 고급을 출력하시오.
- 조건1)칼럼명은 구분으로 하시오
- 조건2)제목은 사원번호 사원명 구분
- 조건3) 구분(오름차순)으로 정렬하고, 같으면 사원명(오름차순)으로 정렬하시오.
```SQL
SELECT EMPLOYEE_ID 사원번호,LAST_NAME 사원명,
   CASE WHEN SALARY < 1000 THEN '초급' 
        WHEN SALARY>=1000 AND SALARY<2500 THEN '중급'
        ELSE '고급' END  AS 구분
FROM employees;
```
### Q17)2000년 이후에 고용된 사원을 찾으시오.
```SQL
SELECT LAST_NAME,to_char(hire_date, 'DD/MM/YYYY')
FROM employees WHERE hire_date>'2000-01-01';
```
### Q16 사원의 레코드를 검색하시오(COUNT,LENGTH)
- 조건1)이름과 성을 연결하시오(CONCAT)
- 조건2)구해진 이름과 길이를 구하시오(LENGTH)
- 조건3)성이 n으로 끝나는 사원(substr)
```SQL
SELECT EMPLOYEE_ID,CONCAT(First_name,last_name),
LENGTH(CONCAT(First_name,last_name))
FROM employees
WHERE SUBSTR(last_name,-1,1) = 'n';
```
### Q15) 사원명,부서ID,입사일을 부서별로 내림차순 정렬하시오.
```SQL
SELECT LAST_NAME,
DEPARTMENT_ID,hire_date
from employees ORDER BY DEPARTMENT_ID desc,hire_date desc ;
```
### Q14) 업무ID에 MAN이 포함되어 있는 사원들의 이름, 업무ID,부서ID를 출력하시오.
```SQL
SELECT LAST_NAME,
job_ID,DEPARTMENT_ID
from employees WHERE job_id like '%MAN%';
```
### Q13) 입사일이 97년인 사원들의 사원번호 ,이름, 입사일을 표시하시오.
```SQL
SELECT employee_id,
LAST_NAME,
hire_date
from employees WHERE hire_date like '05%';
```
### Q12)Employees테이블의 업무ID가 중복되지 않게 표시하는 질의를 작성하시오.
```SQL
Select distinct job_id
from employees
order by job_id asc;
```
### Q11)업무 ID가 'SA-REP'이거나 'AD_PRES'이면서 급여가 15000를 초과하는 사원들의 이름,업무ID
- 급여를 출력하시오.
```SQL
select last_name , job_id , salary
from employees
where job_id in ('SA_REP', 'AD_PRES') and salary>15000 
```

### Q10) 급여가 2500이하 이거나 3000이상이면서 90번 부서인 사원의 이름, 급여, 부서ID를 출력하시오.
- 조건1) 제목은 사원명, 월 급, 부서코드로 하시오
- 조건2) 급여앞에 $를 붙이시오
- 조건3) 사원명은 first_name과 last_name을 연결해서 출력하시오
```SQL
select CONCAT(First_name,last_name) AS 사원명 , salary AS 월급, DEPARTMENT_ID AS 급여코드
from employees WHERE (SALARY<=2500 OR SALARY >3000) AND DEPARTMENT_ID=90 ;
```
### Q9) 사원의 이름과 JOB_ID를 다음과 같이 출력하시오.
```SQL
SELECT last_name ||' is a '|| job_id as "Employee Detail"
from employees;
```
### Q8) 다음과 같이 사원번호 이름 연봉을 출력하시오.
```SQL
SELECT EMPLOYEE_ID 사원번로,LAST_NAME 이름,
SALARY*12 연봉
from employees ORDER BY 1 ASC;
```
### Q7] 급여가 1500이상 5000이하인 사원중 IT_PROG의 업무 ID인 사원을 표시하시오
```SQL
조건1) 제목은 사원이름, 이메일,전화번호
SELECT LAST_NAME,EMAIL,PHONE_NUMBER
FROM EMPLOYEES WHERE (SALARY>=1500 OR SALARY <=5000) AND JOB_ID='IT_PROG';
```
### Q6) 업무ID중 IT가 포함되어있는 사원들의 이름과 업무ID을 구하시오
```SQL
SELECT LAST_NAME,JOB_ID
FROM EMPLOYEES WHERE job_id like '%IT%';
```
### Q5) 커미션을 받지 않는 사원들의 이름과 연봉,커미션을 출력하시오
```SQL
SELECT LAST_NAME,SALARY*12,COMMISSION_PCT
FROM EMPLOYEES WHERE COMMISSION_PCT IS NULL;
```
### Q4) 입사일이 1997~2000 사이의 입사한 사원들의 사원명,입사일, 업무 ID를 출력하시오
```SQL
SELECT LAST_NAME,HIRE_DATE,JOB_ID
FROM EMPLOYEES WHERE HIRE_DATE BETWEEN '1997-01-01' AND '2005-01-01';
```

### Q3)사원테이블에서 업무ID가 IT_PROG,ST_MAN,SA_REP인 사원을 표시하시오
- 조건1) 사원명, 업무ID, 부서ID만 표시
- 조건2) or 연산자 이용 , in 연산자 이용 둘다 쓰시오
```SQL
SELECT employee_id, first_name, job_id, salary, department_id 
FROM employees 
WHERE job_id IN ('ST_MAN', 'SA_MAN', 'SA_REP') ;

SELECT employee_id, first_name, job_id, salary, department_id 
FROM employees 
WHERE job_id ='ST_MAN' OR Job_id ='SA_MAN' OR Job_id= 'SA_REP';
```
### Q2) 사원테이블에서 부서가 90번인 사원들의 사원명,입사일,연봉,부서코드를 출력하시오
- 조건1) 제목은 사원명, 입 사 일,연 봉,부서코드로 하시오(as 별명)
- 조건2) 연봉 = 급여 * 12
- 조건3) 연봉 뒤에 화폐단위 "원"을 붙이시오 (|| 연결연산자)
- 조건4) 사원명은 first_name , last_name을 연결 하시오
```SQL
SELECT FIRST_NAME || ' ' ||last_name as 사원명,hire_date as "입사일",
salary*12||'원'as "연봉",department_id 부서코드
from EMPLOYEES;
```
### Q1) 사원테이블에서 사원번호, 사원명, 급여를 검색하시오
```SQL
SELECT employee_id, LAST_name, job_id, salary
FROM EMPLOYEES;
```

# SQL 서브 쿼리 이너쿼리 퀴즈 및 정리

## SubQuery
1. 주쿼리와 서브쿼리로 구현되는 하나의 구문에서 먼저 서브쿼리가 실행되고 결과를 통해서 주쿼리 연산이 실행된다.
2. SELECT, WHERE, from , group by order by update insert into having에서 사용된다.
3. ()로 묶어서 사용된다. / 비교조건의 오른쪽에 선언된다.  / 일반적으로 ORDER BY 절은 사용하지 않는다.
4. 서브쿼리의 결과가 단일행 다중행으로 나뉜다.
5. 단일행연산자(>,>=,<,<=,==,!=)  다중행연산자(IN, NOT IN, ANY, ALL...)
6. 다중 행 (Multiple-Row) 서브쿼리 ? 하나 이상의 행을 리턴 하는 서브쿼리를 다중 행 서브쿼리라고 한다.
7. ? 복수 행 연산자(IN, ANY, ALL)를 사용한다. 
8. IN : 목록에 있는 임의의 값과 동일하면 참  
9. ANY : 서브쿼리에서 리턴된 각각의 값과 비교하여 하나라도 참이면 참 ( =ANY는IN과 동일)        EX) < ANY  = 최대값보다 적음   ,   >ANY  최소값보다 큼
10. ALL : 서브쿼리에서 리턴된 모든 값과 비교하여 모두 참이어야 참 
       EX) < ALL = 최소값보다 적음   ,   >ALL  최대값 보다 큼- *NOT 연산자는 IN, ANY, ALL 연산자와 함께 사용될 수 있다.

### Q1)JONES보다 월급을 많이 받는 사원의 이름과 봉급을 출력 하자. 
```SQL
SELECT SAL
FROM EMP
WHERE ENAME ='JONES'; --2975

SELECT ENAME,SAL
FROM EMP
WHERE SAL >2975;

SELECT ENAME,SAL
FROM EMP
WHERE SAL >(SELECT SAL
            FROM EMP
            WHERE ENAME ='JONES');
 ```
### Q2)사원번호가 7839인 사원과 같은 직업을 가진 사원들의 이름과 직업을 출력한다.
```SQL
SELECT ENAME,JOB
FROM EMP
WHERE JOB =(SELECT JOB
            FROM EMP
            WHERE EMPNO =7839);
```
            
### Q3)7566 사원보다 급여를 많이 받는 사원이름 급여 출력해보자.
```SQL
SELECT ENAME,SAL
FROM EMP
WHERE SAL >(SELECT SAL
            FROM EMP
            WHERE EMPNO =7566);   
```   
            
### Q4)사원의 봉급의 평군보다 적은 사원의 사원번호 이름 직업 부서번호를 출력해보자.
```SQL
SELECT EMPNO,ENAME,JOB,DEPTNO
FROM EMP
WHERE SAL <(SELECT AVG(SAL)
            FROM EMP); 
```

### Q5) 사원 번호가 7521인 사원과 직업이 같고 봉급이 7934 인 사원보다 많은 사원의 이름, 직업,입사일을 출력해보자.
```SQL
SELECT EMPNO,JOB,HIREDATE,SAL
FROM EMP
WHERE JOB =(SELECT JOB FROM EMP WHERE EMPNO=7521) AND SAL >(SELECT SAL FROM EMP WHERE EMPNO=7934) ; 
```
### Q6) 직업중에서 가장 적은 평균급여를 받는 직업을 출력하자.
```SQL
SELECT JOB,AVG(SAL)
FROM EMP 
GROUP BY JOB
HAVING AVG(SAL) = (SELECT MIN(AVG(SAL))FROM EMP GROUP BY JOB);
```
### Q7) 사원의 봉급이 20번 부서번호의 최소 봉급보다 많은 부서번호를 출력하자.
```SQL
SELECT DEPTNO,MIN(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING MIN(SAL) > (SELECT MIN(SAL)FROM EMP WHERE DEPTNO=20);
```
### Q8) 부서별 최소 봉급과 같은 월급을 받는 사원의 부서번호와 이름을 출력하자.
```SQL
SELECT DEPTNO,ENAME
FROM EMP
WHERE SAL IN (SELECT MIN(SAL)FROM EMP GROUP BY DEPTNO);
```


### 9) 업무가 SALESMAN인 사원의 최소 값보다 급여를 많이 받는 사원의 이름 급여 직업을 출력하자
```SQL
SELECT ENAME,SAL,JOB
FROM EMP
WHERE SAL >ANY (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');
```
### Q10)FORD,BLAKE 와 매니저 및 부서 번호가 같은 사원의 정보를 출력 해보자.
```SQL
SELECT ENAME,mgr,DEPTNO
FROM EMP
WHERE (MGR,DEPTNO) IN 
(SELECT MGR,DEPTNO FROM EMP WHERE  ENAME IN ('FORD','BLAKE'));
```
### Q11) 소속된 부서번호의 평균 급여보다 많은 급여를 받는 사원의 이름, 급여 부서 번호. 입사일,직업
```SQL
SELECT ROUND(AVG(SAL),2)
FROM EMP
WHERE DEPTNO =10; --평균 월급보다 많이 받는 사원은?
```
```SQL
SELECT ENAME,SAL,DEPTNO,HIREDATE,JOB
FROM EMP e
WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO =e.DEPTNO); 
            --E.DEPTNO란? 주쿼리의 테이블의 컬럼을 역참조할 때 별칭을 사용한다.
```
- 상호 연관(Correlated) 서브쿼리 : 상의 질의 즉 주 쿼리에 있는 테이블의 열을 참조하는 것을 말한다.
  1. 메인 쿼리의 하나의 row에서 서브쿼리가 한번씩 실행된다.
  2.  테이블에서 행을 먼저 읽어서 각 행의 값을 관련된 데이터와 비교 한다.
  3. 주 쿼리에서 각 서브쿼리의 행에 대해 다른 결과를 리턴할 때 사용한다.
  4. 4.각 행의 값에 따라 응답이 달라지는 다중 질의의 값을 리턴받을 때 사용한다.
  5. 서브쿼리에서 메인쿼리의 컬럼명을 사용할 수 있지만 메인에서는 서브쿼리의 컬럼명을 사용할 수 없다.

### Q12) 인라인 뷰(inline) : from 절에 서브쿼리 11번을 바꾸어 보자.
```SQL
SELECT e.ENAME,e.DEPTNO,e.JOB
FROM (select ename,job,deptno from emp where job ='MANAGER') e , dept d
where e.deptno = d.deptno;

SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, D.AVGSAL
FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;
 
SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, E.JOB, D.AVGSAL
FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;
```
- 스칼라(Scalar) 서브쿼리
-  하나의 행에서 하나의 열 값만 리턴하는 서브쿼리를 스칼라 서브쿼리라고 한다.
-  스칼라 서브쿼리의 값은 서브쿼리의 select 목록에 있는 항목 값이다.
-  서브쿼리가 0개의 행을 리턴하면 스칼라 서브쿼리의 값은 null이다.
-  서브쿼리가 2개의 이상의 행을 리턴하면 오류가 리턴된다.
-  SELECT (GROUP BY 는 제외),INSERT의 VALUES목록, DECODE의 CASE조건문, UPDATE SET문


### Q13)사원번호, 이름, 부서번호, 사원이 속한 부서의 평균 급여를 출력하자.
```SQL
SELECT EMPNO, ENAME, DEPTNO,SAL,
ROUND((SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO),2) AS M_SAL
FROM EMP E;
```
### Q14)사원번호, 이름, 부서번호, 사원이 속한 부서의 평균 급여를 출력하자.
```SQL
SELECT EMPNO, ENAME, DEPTNO,SAL
FROM EMP E ORDER BY (SELECT DNAME FROM DEPT WHERE DEPTNO = E.DEPTNO);


SELECT EMPNO, ENAME, DEPTNO,SAL,
ROUND((SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO),2) AS M_SAL
FROM EMP E;
```
### Q15)EXISTS 연산자 
#### 부하사원을 가지고 있는[EMPNO=MGR] 사원의 사원의 이름, 직업, 입사일, 급여를 출력하자
```SQL
SELECT EMPNO,ENAME, JOB,HIREDATE,SAL
FROM EMP E
WHERE EXISTS(SELECT 1 FROM EMP WHERE E.EMPNO=MGR)
ORDER BY 1;
```
#### 부하 사원이 없는 있는 ![EMPNO=MGR] 사원의 사원의 이름, 직업, 입사일, 급여를 출력하자
```SQL
SELECT EMPNO,ENAME, JOB,HIREDATE,SAL
FROM EMP E
WHERE NOT EXISTS(SELECT 1 FROM EMP WHERE E.EMPNO=MGR)
ORDER BY 1;
```
# QUESTION
## 1. 'SMITH'보다 월급을 많이 받는 사원들의 이름과 월급을 출력하라.
```SQL
select ename, sal
from emp
where sal >(SELECT SAL FROM EMP WHERE ENAME ='SMITH');
```
## 2. 10번 부서의 사원들과 같은 월급을 받는 사원들의 이름, 월급, 부서번호를 출력하라.
```SQL
select ename, sal,DEPTNO
from emp
where sal in(SELECT SAL FROM EMP WHERE deptno =10);
```

## 3. 'BLAKE'와 같은 부서에 있는 사원들의 이름과 고용일을 뽑는데
#### 'BLAKE'는 빼고 출력하라.
```SQL
select ename, hiredate
from emp
where deptno = (SELECT deptno FROM EMP WHERE ename ='BLAKE') and ename!='BREAK' ;
```

## 4. 평균급여보다 많은 급여를 받는 사원들의 사원번호, 이름, 월급을 출력하되, 월급이 높은 사람 순으로 출력하라.
```SQL
select empno,ename,sal
from emp
where sal> (SELECT avg(sal) FROM EMP) order by sal desc;
```

## 5. 이름에 'T'를 포함하고 있는 사원들과 같은 부서에서 근무하고 있는 사원의 사원번호와 이름을 출력하라.
```SQL
select empno,ename 
from emp 
where deptno in(select deptno from emp where ename like '%T%') ;
```


## 6 자신의 급여가 평균급여보다 많고,이름에 S자가 들어가는 사원과 동일한 부서에서 근무하는 모든 사원의 사원번호,이름 및 급여를 출력하시오
```SQL
--     EMPNO    ENAME      SAL
--    --------  --------  -------
--      7902     FORD       3000
--      7876     ADAMS      1100
--      7788     SCOTT      3000
--      7566     JONES      2975
--      7369     SMITH       800

select empno,ename,sal
from emp 
where sal > (select avg(sal) from emp)
and deptno in(select deptno from emp where ename like '%S%');
```



## 7. 30번 부서에 있는 사원들 중에서 가장 많은 월급을 받는 사원보다 많은 월급을 받는 사원들의 이름, 부서번호, 월급을 출력하라. (단, ALL 또는 ANY 연산자를 사용할 것)
```SQL
select ename,deptno,sal
from emp 
where sal >any (select max(sal) from emp where deptno =30 );

select ename,deptno,sal
from emp 
where sal >all (select sal from emp where deptno =30 );
```

## 8. 'DALLAS'에서 근무하고 있는 사원과 같은 부서에서 일하는 사원의 이름, 부서번호, 직업을 출력하라.
```SQL
select ename,deptno,job
from emp 
where deptno in (select deptno from dept where LOC ='DALLAS');
```

## 9. SALES 부서에서 일하는 사원들의 부서번호, 이름, 직업을 출력하라.
```SQL
select empno,ename,job
from emp 
where deptno in (select deptno from dept where dname ='SALES') ;
```



## 10. 'KING'에게 보고하는 모든 사원의 이름과 급여를 출력하라.(KING에게 보고하는 사원이란 mgr이 KING인 사원을 의미함)
```SQL
select ename,sal
from emp 
where mgr = (select empno from emp where ename ='KING');
```
## 11. 커미션을 받는 사원과 부서번호, 월급이 같은 사원의 이름, 월급, 부서번호를 출력하라.
```SQL
select ename,sal,deptno
from emp 
where deptno in (select deptno from emp where comm is not null)
        and sal in(select sal from emp where comm is not null);
        
select ename,sal,deptno
from emp
where (deptno,sal) in (select deptno,sal from emp where comm is not null);
```


## 12. 30번 부서 사원들과 월급과 커미션이 같지 않은 사원들의 이름, 월급, 커미션을 출력하라.(30번 부서 제외)
```SQL
select ename,sal,comm
from emp
where sal not in (select sal from emp where deptno =30)
        and comm not in (select nvl(comm,0)from emp where deptno =30) ;
```


## 13. 사원번호, 이름, 월급, 그리고 월급누적을 출력하라.
```SQL
--      사원번호  이름   월급   월급누적
--    --------------------------------
--      7369	SMITH	800	800
--	7499	ALLEN	1600	2400
--	7521	WARD	1250	3650

SELECT E.EMPNO, E.ENAME, E.SAL, SUM(D.SAL)
FROM EMP E, (SELECT EMPNO, SAL FROM EMP) D
WHERE E.EMPNO >= D.EMPNO
GROUP BY E.EMPNO, E.ENAME , E.SAL
ORDER BY 1;
```